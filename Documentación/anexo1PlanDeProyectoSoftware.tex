%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Plan del proyecto software}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Introducción
\section{Introducción}
En este anexo se detalla el estudio desde el punto de vista temporal y de la viabilidad del proyecto software.

La planificación es una de las tareas más importantes en el desarrollo de un proyecto software y servirá para determinar objetivos, evaluar la viabilidad del proyecto, priorizar actividades\dots

En la primera parte del anexo se detallará la planificación temporal del proyecto teniendo en cuenta la metodología ágil que se va a utilizar: \scrum{}. En esta fase se determinarán los elementos que forman el \productbacklog{} y la prioridad de cada uno de ellos.

Debido a la metodología empleada, no se utilizará el clásico diagrama de \textit{GANTT}. En lugar de esto, se definirá el \productbacklog{} y para el seguimiento se utilizará una herramienta de gestión especializada en metodologías ágiles, \textit{PivotalTracker}, que permite el seguimiento diario de las tareas por parte del equipo de desarrollo.

En la segunda parte se calcularán los costes, analizando la rentabilidad del proyecto y justificando su desarrollo desde diversos puntos de vista: viabilidad técnica, legal, económica\dots
\newpage



%Planifiación temporal del proyecto
\section{Planificación temporal del proyecto} 
Como se explicó en la memoria, para el desarrollo del proyecto de final de carrera se va, a utilizar una metodología ágil llamada \scrum{}. Esta metodología establece una serie de prácticas que serán llevadas a cabo con algunas limitaciones debido al reducido tamaño del equipo de desarrollo.

Para poder estimar de manera general el tiempo total que va a llevar el desarrollo del proyecto se va a realizar una estimación a partir de los casos de uso definidos en el Anexo II.

\newcommand{\pesoscasosdeuso}{\operatorname{Peso De Casos De Uso}}
\newcommand{\pesosactores}{\operatorname{Peso De Actores}}

\subsection{Estimación temporal a partir de casos de uso}
Antes de mostrar la tabla de estimación temporal, conviene repasar una serie de fórmulas que se utilizan para calcular algunos valores de la tabla:
\begin{itemize}
 \item Puntos de casos de uso no ajustados:
  \[ UUCP = \pesosactores + \pesoscasosdeuso \]
 \item Peso de los casos de uso:
  \[ \pesoscasosdeuso = \sum_{i = 0}^{i} Factor_{i} \]
 \item Peso de los factores técnicos:
  \[ TFC = 0,6 + 0,01 \cdot \sum_{i = 0}^{i} Factor_{i} \cdot Peso_{i} \]
 \item Factores de entorno:
  \[ EF = 1,4 + (-0,03) \cdot \sum_{i = 0}^{i} Factor_{i} \cdot Peso_{i} \]
\end{itemize}

A continuación \vertabla{tablaEstimacionTemporalCasosDeUso}, aparece detallada la duración estimada del desarrollo del proyecto a partir de los casos de uso identificados. Se encuentra dividida en:
\begin{itemize}
 \item Puntos de casos de uso no ajustados: sirven para conocer la envergadura del proyecto tomando como referencia los casos de uso.
 \item Factores técnicos: cuantifica la dificultad del proyecto en función de sus características internas.
 \item Factores del entorno: sirven para valorar lo familiarizado que se encuentra el equipo de desarrollo con proyectos de este tipo.
\end{itemize}

% Estimación temporal a partir de casos de uso.
\tablaSmallSinColores{Estimación temporal a partir de casos de uso}{p{8cm} c c c}{tablaEstimacionTemporalCasosDeUso}{
  \multicolumn{1}{c}{Factor} & \multicolumn{1}{c}{Peso} & \multicolumn{1}{c}{$ F_{i} $} & \multicolumn{1}{c}{Total} \\
 }
 {
  Actores simples                                              & 0  & 1   & 0    \\
  Actores medios                                               & 0  & 2   & 0    \\
  Actores complejos                                            & 1  & 3   & 3    \\
  \rowcolor[gray]{.8} Total peso actores                       &    &     & 3    \\
  Casos de uso simples                                         & 5  & 5   & 25   \\
  Casos de uso medios                                          & 1  & 10  & 10   \\
  Casos de uso complejos                                       & 2  & 15  & 30   \\
  \rowcolor[gray]{.8} Total peso casos de uso                  &    &     & 65   \\
  \rowcolor[gray]{.8} UUCP (Puntos de caso de uso no ajustados)&    &     & 68   \\
  Sistema distribuido                                          & 1  & 2   & 2    \\
  Tiempos de respuesta críticos                                & 1  & 1   & 1    \\
  En línea                                                     & 1  & 1   & 1    \\
  Procesos internos complejos                                  & 5  & 1   & 5    \\
  El código debe ser reutilizable                              & 3  & 1   & 3    \\
  Fácil de instalar                                            & 1  & 0,5 & 0,5  \\
  Fácil de utilizar                                            & 5  & 0,5 & 2,5  \\
  Portable                                                     & 1  & 2   & 2    \\
  Fácil de modificar                                           & 4  & 1   & 4    \\
  Concurrencia                                                 & 1  & 1   & 1    \\
  Incluye características de seguridad                         & 1  & 1   & 1    \\
  Acceso a software creado por otras compañías                 & 1  & 1   & 1    \\
  Incluye facilidades de aprendizaje para usuario              & 5  & 1   & 5    \\
  \rowcolor[gray]{.8} TF (Factores técnicos)                   &    &     & 0,89 \\
  Familiarizado con \scrum{}                                   & 1  & 0,5 & 0,5  \\
  Experiencia en este tipo de aplicaciones                     & 2  & 1   & 2    \\
  Experiencia en Orientación a Objetos                         & 5  & 0,5 & 2,5  \\
  Capacidad de liderazgo del analista                          & 5  & 1   & 5    \\
  Motivación                                                   & 5  & 1   & 5    \\
  Requisitos estables                                          & 3  & 2   & 6    \\
  Trabajadores a tiempo parcial                                & 5  & -1  & -5   \\
  Lenguaje de programación difícil de utilizar                 & 1  & -1  & -1   \\
  \rowcolor[gray]{.8} EF (Factores de entorno)                 &    &     & 0,95 \\
 }

Los puntos de casos de uso se calculan según la siguiente fórmula:
\[ UCP = UUCP \cdot TF \cdot EF \]

Para calcular los puntos de casos de uso hay que sustituir, en la fórmula anterior, con los valores de la tabla, es decir:
\[ UCP = 68 \cdot 0,89 \cdot 0,95 = 57,494 \]

Para obtener la duración del proyecto estimado según los casos de uso hay que multiplicar el valor de \textit{UCP} por un factor que depende del número de factores de entorno (\textit{EF}) a los cuales se les haya dado peso 0. En este caso, como no se ha dado ningún valor cero se multiplica por 20.

Por lo expuesto anteriormente: $ Nº horas = 20 \cdot 57,494 $, es decir, 1150 horas/hombre. [CAMBIAR]

Conviene destacar que los resultados obtenidos son meramente orientativos, ya que se va a utilizar una metodología ágil, por lo que la planificación va a ser a nivel de \sprint{} (de 15 a 30 días). Al comenzar cada uno de ellos, se definirán una serie de tareas que deberán ser completadas en dicho \sprint{}.

El proyecto comenzará en noviembre de 2012 y se desea finalizar en junio de 2013, es decir, se trabajará durante 7 meses. Se deben realizar los cálculos de horas para comprobar si es viable el desarrollo en las fechas previstas:
\newcommand{\tiempo}{\operatorname{Tiempo}}
\newcommand{\horas}{\operatorname{horas}}
\newcommand{\persona}{\operatorname{persona}}
\newcommand{\jornada}{\operatorname{jornada}}
\newcommand{\jornadas}{\operatorname{jornadas}}
\newcommand{\mes}{\operatorname{mes}}
\newcommand{\meses}{\operatorname{meses}}
\newcommand{\semana}{\operatorname{semana}}
\newcommand{\hora}{\operatorname{hora}}

\[
 \tiempo = \dfrac{1150 \horas}{1 \persona} \cdot \dfrac{1 \jornada}{7 \horas} \cdot \dfrac{1 \mes}{20 \jornadas} = 8,21 \meses
\]

El análisis de casos de uso junto con el horario marcado hace que la fecha de finalización deba trasladarse hasta julio para poder cumplir los plazos. De este modo la fecha de finalización del proyecto se retrasa hasta julio de 2010, manteniendo la jornada laboral de 35 horas semanales.

[TODO ESTO HAY QUE CAMBIARLO, PERO NOS SIRVE DE PLANTILLA]
\newpage


%Aplicando una metodología ágil: SCRUM
\section{Aplicando una metodología ágil: \textit{SCRUM}}
En esta sección se repasa de una manera rápida los principales aspectos del desarrollo de proyectos con \scrum{}. Al mismo tiempo se analizan los distintos roles que va a asumir cada uno de los participantes en el proyecto de final de carrera.

Conviene aclarar que los términos que define la metodología \scrum {} se encuentran en inglés, han sido mantenidos en el idioma original para no confundir con las traducciones.

\scrum{} \citeotras{scrum} es una metodología para la gestión y desarrollo de proyectos software basada en un proceso iterativo e incremental. Cada iteración termina con una pieza de software ejecutable que incorpora una nueva funcionalidad o mejora las ya existentes. Estas iteraciones suelen durar de dos a cuatro semanas.

\scrum{} busca priorizar los trabajos que mayor valor aportan al negocio evitando, en la medida de lo posible, complejos manuales de documentación que no tengan utilidad en el proceso.

Los requerimientos y prioridades se revisan y ajustan durante el proyecto en intervalos cortos y regulares. De esta forma es sencillo adaptarse a los cambios solicitados por el cliente y responder de una forma rápida a los mismos.

\subsection{Actores}
\scrum{} define un conjunto de roles o actores detallados a continuación:
\begin{itemize}
 \item \textit{Scrum Master} (o facilitador): coordina el desarrollo del proyecto y trabaja de manera similar al director de proyectos. Una de sus tareas es eliminar los obstáculos que puedan dificultar al equipo de desarrollo o \textit{team} la consecución de sus objetivos. En el proyecto, este rol lo han tomado los autores del mismo: Adrián González y Joaquín Bravo.
 \item \textit{Scrum Team} (o equipo): incluye a los desarrolladores y son los encargados de realizar las tareas que se definen en cada \sprint{}. En el proyecto, este rol lo han tomado los autores del mismo.
 \item \textit{Product Owner} (o cliente): representa la voz del cliente y aporta la visión del negocio. Representa el destinatario final del proyecto a desarrollar y el que, en última instancia, realiza las pruebas de aceptación. Es también el encargado de mantener al día el listado de las tareas o \productbacklog{} y sus prioridades. En el proyecto este rol sería tomado por la Universidad de Burgos, en concreto, personalizado en los tutores del proyecto César I. García Osorio y José Francisco Díez Pastor.
\end{itemize}

\subsection{Ciclo de desarrollo}
Al inicio del proyecto se definen una serie de requisitos que serán los objetivos a cumplir. Todos ellos quedan reflejados en el \productbacklog{}. Cada uno de estos objetivos serán subdivididos en tareas pequeñas y atómicas al inicio de cada \sprint{}.

El ciclo de desarrollo, como se muestra \ver{scrumProcess}, es iterativo a nivel de \sprint{}, al inicio del mismo se extraen una serie de tareas de los elementos del \productbacklog{} que conforman el \sprintbacklog{}. Estas tareas deberán ser completadas durante el ciclo.

%Ciclo de desarrollo con Scrum.
\figura{1}{imgs/ScrumProcess.png}{Metodología Scrum}{ScrumProcess}{}

\scrum{} define que debe realizarse una breve reunión diaria \textit{Daily Meeting} en la que, cada miembro del equipo de desarrollo, explica lo que ha hecho desde la última sincronización, que va a hacer a partir de ese momento y las dificultades encontradas o que espera encontrar. En este caso, debido a que el equipo de desarrollo está formado por un único desarrollador, se va a omitir esta reunión y se sustituye por una pequeña reflexión interior en la que analizar las tareas a desarrollar durante el día.

Los \sprints{} se definirán, como establece \scrum{}, con una duración de dos a cuatro semanas que podrán alargarse o contraerse para coincidir con los tutores para las reuniones periódicas que establece:
\begin{itemize}
 \item \textit{Planning meeting}: reunión inicial de cada \sprint{} en la que se extraen los \textit{item backlog}. Se numeran las tareas extraídas del \productbacklog{} para desarrollar durante el \sprint{}. Esta reunión tiene una gran importancia ya que, durante el desarrollo del \sprint{}, no se podrá modificar ni añadir nuevas tareas.
 \item \textit{Review meeting}: reunión final (4 horas máximo) de cada \sprint{} donde se detallan los objetivos cumplidos durante el mismo. Se muestra al usuario el producto, en caso de que sea posible. En función de los resultados mostrados y de los cambios que haya habido en el contexto del proyecto, el cliente realiza las adaptaciones necesarias de manera objetiva, ya desde la primera iteración, replanificando el proyecto.
 \item \textit{Retrospective meeting}: en esta reunión (4 horas máximo), el equipo analiza cómo ha sido su manera de trabajar y cuáles son los problemas que podrían impedirle progresar adecuadamente, mejorando de manera continua su productividad. El \textit{Scrum Master}, o \textit{Facilitador}, se encargará de ir eliminando los obstáculos identificados.
\end{itemize}

En este caso, todas las reuniones requieren de la presencia de los tutores y del equipo de desarrollo ya que entre ambos, agrupan los roles que se ven implicados en dichas reuniones.
\newpage



%Product backlog
\section{Product Backlog del proyecto}
En esta sección, aparece redactado el \productbacklog{} \vertabla{productBacklog} o lista de objetivos, con la prioridad de cada una de los \productitem{}, el \textit{sprint} al que pertenecen y la estimación que les dimos en su momento, basándonos en una escala de puntos tipo Fibonacci (1, 2, 3, 5, 8). Hemos decidido incluir también los \textit{bugs} que se han ido localizando[INSERTAR CITA].

\scrum{} no define un método o herramienta para llevar el día a día del trabajo realizado, por lo que el seguimiento se puede realizar con una simple hoja de cálculo, o con herramientas de gestión especializadas en este tipo de desarrollos.

En este caso, se ha utilizado \textit{PivotalTracker} (\url{https://www.pivotaltracker.com/}) para el seguimiento. Es un software potente al que se accede mediante un navegador y sirve de control de tareas y defectos. Su licencia ha sido gratuita por tratarse de un proyecto público.

%Tabla que contiene el Product Backlog
\tabla{Product Backlog}{c p{5cm} p{2cm} c c c}{4}{productBacklog}{
  \multicolumn{1}{c}{ID} & \multicolumn{1}{c}{Backlog Item} & \multicolumn{1}{c}{Propietario} & \multicolumn{1}{c}{Prioridad} & \multicolumn{1}{c}{Estimación} & \multicolumn{1}{c}{Sprint} \\
 }
 {
  S-01001 & Se debe poder cargar una imagen y sacar información de sus píxeles & César, José & Alta & 2 & Sprint 1 \\
  S-01002 & Se debe poder analizar una imagen y extraer sus características & César, José & Alta & 5 & Sprint 2  \\
  S-01003 & La aplicación debe ser capaz de calcular una imagen Saliency Map & César, José & Alta & 5 & Sprint 3 \\
  S-01004 & La aplicación debe poder calcular las características de Haralick & César, José & Alta & 8 & Sprint 3 \\
  S-01005 & La aplicación debe ser capaz de generar ficheros ARFF & César, José & Alta & 5 & Sprint 3 \\
  S-01006 & La aplicación debe ser capaz de calcular los eigenvalues mediante weka.Matrix o COLT & César, José & Baja & 1 & Sprint 4 \\
  S-01007 & La aplicación debe ser capaz de dividir la imagen según los hilos disponibles, con solapamiento entre las mismas  & César, José & Alta & 1 & Sprint 4  \\
  S-01008 & La aplicación debe ser capaz de realizar la convolución de la imagen completa, para extraer la media & César, José & Media & 3 & Sprint 4  \\
  S-01009 & La aplicación debe ser capaz de albergar varios tipos de ventana & César, José & Alta & 1 & Sprint 4  \\
  S-01010 & La aplicación debe ser capaz de entrenar un clasificador y clasificar & César, José & Alta & 5 & Sprint 4  \\
  S-01011 & La aplicación debe ser capaz de mostrar un GUI con las principales opciones & César, José & Alta & 5 & Sprint 4  \\
  S-01012 & La aplicación debe mostrar el progreso en una Progress Bar & César, José & Baja & 2 & Sprint 5  \\
  S-01013 & La aplicación debe mostrar un aviso si no se selecciona una región de la imagen a analizar & César, José & Baja & 1 & Sprint 5  \\
  S-01014 & La ventana de resultados se debe limpiar después de cada análisis & César, José & Media & 1 & Sprint 5  \\
  S-01015 & La aplicación debe escribir un ARFF por cada hilo, uniéndolos al terminar el proceso & César, José & Alta & 3 & Sprint 5  \\
  S-01016 & La aplicación debe mostrar eventos de funcionamiento en la interfaz & César, José & Media & 2 & Sprint 5  \\
  S-01017 & La aplicación debe guardar y cargar en un fichero las opciones & César, José & Media & 3 & Sprint 5  \\
  S-01018 & La aplicación debe ser capaz de guardar un log de errores & César, José & Baja & 2 & Sprint 5  \\
  S-01019 & La aplicación debe usar el filtro saliency para calcular características para entrenar y clasificar & César, José & Alta & 3 & Sprint 5  \\
  S-01020 & La aplicación debe usar la convolución de la imagen completa, en el caso de que no se elija región, o toda la región más un margen & César, José & Alta & 3 & Sprint 5  \\
  S-01021 & La aplicación debe poder dibujar los defectos encontrados & César, José & Alta & 3 & Sprint 5  \\
  S-01022 & La aplicación debe ser capaz de usar varios tipos de métodos para determinar si una ventana es defectuosa o no & César, José & Alta & 8 & Sprint 5  \\
  S-01023 & La aplicación debe mostrar un slider para seleccionar el umbral de detección & César, José & Alta & 3 & Sprint 5  \\
  S-01024 & La aplicación debe ser capaz de escribir texto formateado en HTML en el panel de log & César, José & Baja & 3 & Sprint 6  \\
  S-01025 & La aplicación debe ser capaz de exportar el log en formato HTML & César, José & Baja & 2 & Sprint 6  \\
  S-01026 & La aplicación debe tener un menú con varias opciones & César, José & Media & 2 & Sprint 6  \\
  S-01027 & La aplicación debe usar REPTree para regresión lineal & César, José & Media & 1 & Sprint 6  \\
  S-01028 & La aplicación debe ser capaz de calcular filtros de umbrales locales y comprobar si las regiones candidatas están dentro de la máscara & César, José & Alta & 5 & Sprint 6  \\
  S-01029 & La aplicación debe dirigir la búsqueda de defectos usando filtros de umbrales locales & César, José & Alta & 5 & Sprint 6  \\
  B-01001 & BUG: la primera y segunda derivadas deben estar bien calculadas  & César, José & Alta & - & Sprint 6  \\
  S-01030 & La aplicación debe dar la oportunidad al usuario de elegir el proceso de detección de defectos & César, José & Media & 2 & Sprint 7  \\
  S-01031 & La aplicación debe calcular los umbrales locales con un pequeño margen & César, José & Media & 2 & Sprint 7  \\
  S-01032 & La aplicación debe ser capaz de generar un conjunto de datos a partir de la ventana deslizante & César, José & Alta & 3 & Sprint 7  \\
  S-01033 & La aplicación debe poder remuestrear la lista de píxeles blancos, de tal manera que no considere todos & César, José & Alta & 5 & Sprint 7  \\
  S-01034 & La aplicación debe ser capaz de calcular características geométricas sobre las regiones segmentadas & César, José & Alta & 5 & Sprint 7  \\
  S-01035 & Se debe poder mostrar una tabla resumen de los defectos & César, José & Alta & 5 & Sprint 7  \\
  S-01036 & La aplicación debe permitir al usuario qué tipo de clasificación se va a usar: clases nominales o regresión & César, José & Media & 2 & Sprint 8  \\
  S-01037 & La aplicación debe añadir un borde a la selección en aquellas zonas que no coincidan con los bordes de la imagen & César, José & Media & 3 & Sprint 8  \\
  S-01038 & La aplicación debe permitir al usuario qué tipo de ventana defectuosa quiere usar  & César, José & Media & 3 & Sprint 8  \\
  S-01039 & Se debe añadir un módulo de ayuda en línea (JavaHelp), accesible desde el menú y con teclas rápidas (F1)  & César, José & Media & 3 & Sprint 8  \\
  S-01040 & La aplicación debe poder permitir seleccionar una fila de la tabla de resultados e iluminar el defecto correspondiente  & César, José & Alta & 5 & Sprint 8  \\
  S-01041 & La aplicación debe dar la opción de elegir si se calculan todas las características o sólo mejores  & César, José & Media & 3 & Sprint 8  \\
  S-01042 & La aplicación debe tratar las excepciones de forma correcta, mostrando avisos  & César, José & Media & 3 & Sprint 8  \\
  B-01002 & BUG: la aplicación debe impedir la reselección mientras se analiza  & César, José & Alta & - & Sprint 8  \\
 }
\newpage


%Planificación por Sprint
\section{Planificación por Sprint}
En esta sección aparece el listado de los diversos \sprints{} del proyecto. La información de cada uno está dividida del siguiente modo:
\begin{itemize}
 \item \textit{Planning meeting}: acta de la reunión inicial de cada \sprint{} en la que se detallan los objetivos a cumplir durante el transcurso del mismo.
 \item \textit{Sprint planning}: se numeran las tareas extraídas del \productbacklog{} para desarrollar durante el \sprint{}.
 \item \textit{Burndown chart}: gráfico que muestra la evolución a lo largo del \sprint{} en comparación a la línea óptima.
 \item \textit{Retrospective meeting}: acta de la reunión retrospectiva realizada al final del \sprint{} y donde se analizan los problemas detectados durante su ejecución y las desviaciones (en caso de haberlas).
\end{itemize}

Debido a la falta de conocimiento inicial y a la incertidumbre sobre el desarrollo, se inicia el proyecto con \sprints{} de corta duración, aproximadamente dos semanas. Se ha intentado mantener siempre esta duración, aunque a veces nos ha podido el optimismo y hemos metido demasiado trabajo o no se han tenido en cuenta ciertos problemas de tiempo.

Las reuniones inicial y final de cada \sprint{} se solaparon para poder hacerlas el mismo día, debido a problemas de tiempo y de disponibilidad. Así, media parte de esta reunión se centraba en la \textit{Planning meeting} y la otra en la \textit{Retrospective meeting}.


\subsection{Sprint 1: Spike Arquitectónico 1}
\subsubsection*{Planning meeting}
En este primer \sprint{} se pretende comenzar el proyecto, empezar a usar ImageJ, familiarizarnos con el proyecto del año pasado... Se empiezan a poner en práctica algunas de las ideas que teníamos para el diseño de la aplicación. Lo llamamos \textit{spike arquitectónico} debido a que es una primera aproximación al proyecto, tomando prestado el nombre de otra metodología ágil (\textit{Extreme Programming}).

\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este primer \sprint{} comienza el 19/11/2012 y su fecha límite es el 27/11/2012. Es un \sprint{} muy corto debido a que es una primera aproximación. Los puntos totales estimados en este \sprint{} son de 2.

\subsubsection*{Sprint planning}
\begin{itemize}
\item  S-01001: Se debe poder cargar una imagen y sacar información de sus píxeles.
	\begin{itemize}
	\item TK-00001: Carga y manejo de la imagen con ImageJ.
	\item TK-00002: Creación de la ventana deslizante (simple).
	\item TK-00003: Creación de una pequeña interfaz que muestre los resultados.
	\end{itemize}
\end{itemize}

\subsubsection*{Burndown chart}
Para este \sprint{} no disponemos de \burndownchart{} debido a un fallo en el uso de \textit{Pivotal Tracker}. Como aún no estábamos familiarizados con él, finalizamos antes la \textit{release} que la historia de usuario, con lo que no se ve reflejado en el \burndownchart{}.

\subsubsection*{Retrospective meeting}
¿Qué ha ido bien?
\begin{itemize}
 \item La lectura de artículos y comprensión del proyecto avanza por buen camino.
 \item Nos vamos familiarizando con ImageJ y el resto de nuevas herramientas.
\end{itemize}

¿Qué dificultades ha habido?
\begin{itemize}
 \item Familiarizarse con ImageJ es difícil. Por ello, llegamos a plantearnos el uso de alguna otra librería, como \textit{OpenCL}, pero acabamos descartándolo debido a que ImageJ tienen muy buena documentación, cosa que el resto no.
 \item Adaptación a la nueva metodología.
\end{itemize}


\subsection{Sprint 2: Spike Arquitectónico 2}
\subsubsection*{Planning meeting}
Como seguimos probando cosas más que implementar funcionalidad nueva, consideramos a este \sprint{} otro \textit{spike}, aunque este está ya más orientado a nueva funcionalidad. Básicamente, lo que buscamos en este \sprint{} es:

\begin{enumerate}
\item Seguir familiarizándonos con ImageJ.
\item Convertir la aplicación en multihilo, dividiendo la imagen a analizar en tantas partes como procesadores tenga la máquina y analizando cada trozo en un hilo separado.
\item Implementar los algoritmos de extracción de características, usando lo que se pueda del proyecto del año pasado.
\end{enumerate}

También comentamos otras cosas como que, de momento, vamos a sacar los resultados por pantalla, pero que hay que ir pensando en sacarlos a un fichero. También tenemos que pensar que hay que usar \textit{Saliency Map} para el preprocesamiento.

\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este \sprint{} comienza el 27/11/2012 y la fecha límite es el 11/12/2012. El número total de puntos estimado es de 5.

\subsubsection*{Sprint planning}
\begin{itemize}
\item S-01002: Se debe poder analizar una imagen y extraer sus características.
	\begin{itemize}
	\item TK-00004: Implementación de la ventana deslizante multihilo.
	\item TK-00005: Implementación de los algoritmos de selección de características.
	\item TK-00006: Implementación de las llamadas a los algoritmos de selección de características y muestra de los resultados.
	\end{itemize}
\end{itemize}

\subsubsection*{Burndown chart}
En el \burndownchart{} \ver{burndownChartSprint2} podemos ver 2 cosas:

\begin{enumerate}
\item Hay una incoherencia en las fecha de inicio, ya que, de nuevo, por la falta de conocimientos del uso de \textit{PivotalTracker}, metimos una historia de usuario antes de tiempo y después nos limitamos a cambiar el nombre, dándonos cuenta mucho después de que lo habíamos hecho mal.
\item Tuvimos ciertos problemas de tiempo y de implementación, por lo que hay un tiempo totalmente plano en el que no pudimos terminar ninguna tarea, lo que llevó a pasarnos de fecha hasta el 18/12/2012.
\end{enumerate}

%Burndown chart del Sprint 2.
\figura{1}{imgs/burndownChartSprint2.png}{Burndown Chart del segundo Sprint}{burndownChartSprint2}{}

\subsubsection*{Retrospective meeting}
¿Qué ha ido bien?
\begin{itemize}
 \item Cada vez dominamos más ImageJ.
 \item Hemos conseguido implementar con éxito el multihilo.
 \item Las implementaciones de los algoritmos de extracción de características del año pasado parece que van bien, por lo que decidimos mantenerlas.
 \item El diseño que habíamos pensado se está probando ser bueno.
\end{itemize}

¿Qué dificultades ha habido?
\begin{itemize}
 \item Hemos planificado mal este \sprint{}, ya que fuimos muy optimistas respecto al tiempo y a las dificultades. Tuvimos mucha carga de trabajo de otras asignaturas.
 \item Tuvimos problemas con las coordenadas, lo que nos quitó mucho tiempo.
\end{itemize}

\subsection{Sprint 3}
\subsubsection*{Planning meeting}
En este \sprint{} lo que se pretende es:

\begin{enumerate}
\item Implementar las características de Haralick, que por ser muy pesadas, no se hicieron en el anterior \sprint{}.
\item Calcular el \textit{Saliency Map} para el preprocesamiento de la imagen.
\item Generar un fichero ARFF con el resultado de los análisis.
\end{enumerate}

Como vemos, algunas de las cosas que se hablaron en anteriores reuniones se ponen en práctica en este \sprint{}.

\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este \sprint{} se planificó de manera especial, ya que por medio están las vacaciones de Navidad y el periodo de exámenes del primer cuatrimestre. Por eso es más largo de lo normal: del 19/12/2012 al 24/01/2013. El número total de puntos estimado es de 18.

\subsubsection*{Sprint planning}
\begin{itemize}
 \item S-01003: La aplicación debe ser capaz de calcular una imagen Saliency Map.
 \begin{itemize}
  \item TK-00007: Implementar el cálculo de Saliency Map.
  \item TK-00008: Adición de los Saliency Map a la estructura del programa.
 \end{itemize} 
 \item S-01004: La aplicación debe poder calcular las características de Haralick.
 \begin{itemize}
  \item TK-00009: Implementar características de Haralick.
  \item TK-00010: Añadirlo a la estructura del patrón Estrategia de algoritmos.
 \end{itemize}
 \item S-01005: La aplicación debe ser capaz de generar ficheros ARFF.
 \begin{itemize}
  \item TK-00011: Generación de ARFF a partir de los datos de las características.
 \end{itemize}
\end{itemize}

\subsubsection*{Burndown chart}
En el \burndownchart{} \ver{burndownChartSprint3} podemos ver que hay un gran periodo totalmente plano, en el que no pudimos prácticamente hacer nada del proyecto. Esto estaba previsto y controlado, y por eso planificamos este \sprint{} con tanto tiempo.

%Burndown chart del Sprint 3.
\figura{1}{imgs/burndownChartSprint3.png}{Burndown Chart del tercer Sprint}{burndownChartSprint3}{}

Por lo demás, vemos que en este \sprint{} no nos pasamos de la fecha límte.

\subsubsection*{Retrospective meeting}
¿Qué ha ido bien?
\begin{itemize}
 \item Los nuevos algoritmos parecen funcionar bien lo que había el año pasado, por lo que decidimos mantenerlo (excepto una cosa, de la que hablaremos más tarde).
 \item El diseño que habíamos pensado se vuelve a probar ser bueno, ya que permite añadir nuevos algoritmos muy fácilmente.
\end{itemize}

¿Qué dificultades ha habido?
\begin{itemize}
 \item La implementación de la última característica de Haralick es muy lenta. Hemos observado que los alumnos del año pasado hicieron su propia clase de cálculos de matrices, cosa que nos pareció absurda y contraproducente. De hecho, ellos anularon esta característica para presentar el proyecto.
 \item En este \sprint{} quizás nos pasamos estimando el tiempo de cada tarea, debido en parte a lo que nos pasó en el anterior \sprint{}.
\end{itemize}


\subsection{Sprint 4}
\subsubsection*{Planning meeting}
En este \sprint{} planeamos hacer:

\begin{itemize}
\item Probar implementaciones alternativas para los autovalores de una matriz (Weka, COLT...).
\item Añadir un solapamiento al dividir las imágenes para el multihilo, para tener en cuenta la importancia de los pixeles de la división, ya que pueden ser importantes en la otra parte de la imagen.
\item Modificar la convolución de las imágenes para hacerlo con la imagen completa.
\item Entrenar un clasificador, para lo que hace falta una ventana aleatoria.
\item Implementar la interfaz de usuario.
\end{itemize}

Además, se habló de otras cosas, como el ir probando los umbrales adaptitivos en ImageJ, o cosas que deben ir en la memoria (la metodología debe aparecer en el apartado de técnicas, resaltar los aspectos relevantes y nuevos del proyecto de este año \textit{versus} la versión del año pasado...). Llegamos incluso a hablar de la idea de clasificar los defectos en tipo, para lo cual es necesario calcular características geométricas.

\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este \sprint{} se inicia el 26/01/2013 y tiene como fecha límite el 15/02/2013. Tiene un total de puntos estimados de 20.


\subsubsection*{Sprint planning}
\begin{itemize}
 \item S-01006: La aplicación debe ser capaz de calcular los eigenvalues mediante weka.Matrix o COLT.
 \begin{itemize}
  \item TK-00012: Añadir las librerías necesarias.
  \item TK-00013: Sustituir la llamada a eigenvalues por el método correspondiente de las nuevas librerías.
 \end{itemize}
 \item S-01007: La aplicación debe ser capaz de dividir la imagen según los hilos disponibles, con solapamiento entre las mismas.
 \begin{itemize}
  \item TK-00014: Modificar la división de las imágenes para permitir un solapamiento.
 \end{itemize}
 \item S-01008: La aplicación debe ser capaz de realizar la convolución de la imagen completa, para extraer la media.
 \begin{itemize}
  \item TK-00015: Calcular la convolución de la imagen completa.
  \item TK-00016: Calcular sobre la convolución la primera y segunda derivadas.
 \end{itemize}
 \item S-01009: La aplicación debe ser capaz de albergar varios tipos de ventana.
 \begin{itemize}
  \item TK-00017: Crear el patrón estrategia.
  \item TK-00018: Creación de la clase de la ventana aleatoria.
 \end{itemize}
 \item S-01010: La aplicación debe ser capaz de entrenar un clasificador y clasificar.
 \begin{itemize}
  \item TK-00019: Crear 2 listas de píxeles centrales: una con defectos y otra sin defectos.
  \item TK-00020: Seleccionar de forma aleatoria ventanas sobre las que calcular características, a partir de las 2 listas.
  \item TK-00021: Entrenar a un clasificador y guardar el modelo obtenido.
  \item TK-00022: Clasificar defectos.
 \end{itemize}
 \item S-01011: La aplicación debe ser capaz de mostrar un GUI con las principales opciones.
 \begin{itemize}
  \item TK-00023: Implementación de la GUI.
  \item YK-00024: Adaptación del resto del código.
 \end{itemize}
\end{itemize}

\subsubsection*{Burndown chart}
En el \burndownchart{} \ver{burndownChartSprint4} podemos ver que el desarrollo fue bastante escalonado, teniendo periodos planos en los que no podíamos avanzar debido a las dificultades.

%Burndown chart del Sprint 4.
\figura{1}{imgs/burndownChartSprint4.png}{Burndown Chart del cuarto Sprint}{burndownChartSprint4}{}

Todo esto al final hizo que nos pasáramos de fecha, ya que acabamos el 21 de febrero.


\subsubsection*{Retrospective meeting}
¿Qué ha ido bien?
\begin{itemize}
 \item El diseño que habíamos pensado se vuelve a probar ser bueno, ya que, usando la misma idea para las ventanas que para los algoritmos, nos permite añadir nuevos tipos de ventana fácilmente.
 \item El entrenamiento funciona bien. Esto nos permitió ganar mucha comprensión acerca de cómo funciona esta parte del proyecto.
 \item La GUI implementada es más intuitiva que la del año pasado.
\end{itemize}

¿Qué dificultades ha habido?
\begin{itemize}
 \item Los autovalores siguen siendo muy lentos.
 \item Mala planificación: nos pasamos metiendo historias en este \sprint{}, por lo que nos ha llevado algo más de tiempo del previsto.
 \item Fallo extraño al crear el ARFF de entrenamiento: hay veces que los hilos no lo hacen bien.
\end{itemize}


\subsection{Sprint 5}
\subsubsection*{Planning meeting}
En este \sprint{} planeamos hacer:

\begin{itemize}
\item Mejorar ciertos aspectos de la interfaz (barra de progreso, eventos en el log...).
\item Solucionar el fallo al escribir los ARFF (decidimos que cada hilo escriba en un fichero y luego se fusionen).
\item Dibujar los defectos encontrados.
\item Solucionar ciertos aspectos que no habían quedado claros respecto a los \textit{Saliency Map} y a las convoluciones.
\item Implementar nuevas formas de determinar cuándo una ventana es defectuosa o no en el entrenamiento.
\item Implementar la selección del umbral de detección de defectos.
\item Implementar la carga y almacenamiento de opciones.
\end{itemize}

Las nuevas formas de determinar cuándo una ventana es defectuosa son las que ya mencionamos en la parte teórica de esta memoria:

\begin{itemize}
\item Un píxel mal, toda la ventana mala (enfoque del año pasado).
\item Píxel central malo, toda la ventana mala.
\item Porcentaje de píxeles malos.
\item Porcentaje de píxeles malos en una región de vecinos $3\times3$ centrada en el píxel central.
\end{itemize}

Además, se habla de analizar si es mejor \textit{Random Forest} que \textit{Bagging} y la posibilidad de incluir un árbol para poder seleccionar el algoritmo de clasificación.

\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este \sprint{} se inicia el 21/02/2013 y tiene como fecha límite el 12/03/2013. Tiene un total de puntos estimados de 34.

\subsubsection*{Sprint planning}
\begin{itemize}
 \item S-01012: La aplicación debe mostrar el progreso en una Progress Bar.
 \begin{itemize}
   \item TK-00025: Actualizar el progreso de la ProgressBar en el análisis de la imagen.
   \item TK-00026: Actualizar el progreso de la PorgressBar en el entrenamiento.
  \end{itemize}
 \item S-01013: La aplicación debe mostrar un aviso si no se selecciona una región de la imagen a analizar.
 \begin{itemize}
   \item TK-00027: Creación del aviso con 2 botones: Continuar y Cancelar el proceso.
  \end{itemize}
 \item S-01014: La ventana de resultados se debe limpiar después de cada análisis.
  \begin{itemize}
   \item TK-00028: Limpiar la ventana si se para la ejecución o si se vuelve a lanzar el proceso.
  \end{itemize}
 \item S-01015: La aplicación debe escribir un ARFF por cada hilo, uniéndolos al terminar el proceso.
  \begin{itemize}
   \item TK-00029: Generación de un ARFF nuevo en cada hilo, sobre el que va a escribir cada uno.
   \item TK-00030: Fusión de todos los ARFF generados al terminar el proceso.
   \item TK-00031: Entrenamiento del clasificador con el ARFF fusionado.
   \item TK-00032: Mover la funcionalidad de generar el modelo a otra clase.
  \end{itemize}
 \item S-01016: La aplicación debe mostrar eventos de funcionamiento en la interfaz.
  \begin{itemize}
   \item TK-00033: Escritura en el campo de texto de la interfaz cada vez que ocurre un evento.
  \end{itemize}
 \item S-01017: La aplicación debe guardar y cargar en un fichero las opciones.
  \begin{itemize}
   \item TK-00034: Creación de un fichero de propiedades, con las opciones por defecto.
   \item TK-00035: Creación de una clase de utilería que sea capaz de leer y escribir el fichero de opciones.
   \item TK-00036: Sustituir algunos de los parámetros dentro del programa por llamadas a la clase de lectura/escritura de propiedades.
  \end{itemize}
 \item S-01018: La aplicación debe ser capaz de guardar un log de errores.
  \begin{itemize}
   \item TK-00037: Creación de una clase que escriba el log.
   \item TK-00038: Escritura en el log en cada excpeción.
  \end{itemize}
 \item S-01019: La aplicación debe usar el filtro saliency para calcular características para entrenar y clasificar.
  \begin{itemize}
   \item TK-00039: Uso de las imágenes saliency al mismo tiempo que las normales a la hora de calcular las características.
   \item TK-00040: Generación de un ARFF con las características de las imágenes saliency.
  \end{itemize}
 \item S-01020: La aplicación debe usar la convolución de la imagen completa, en el caso de que no se elija región, o toda la región más un margen.
  \begin{itemize}
   \item TK-00041: Calcular el margen de la región y crear con ello una nueva imagen, para pasarla a la ventana.
  \end{itemize}
 \item S-01021: La aplicación debe poder dibujar los defectos encontrados.
  \begin{itemize}
   \item TK-00042: Creación de matriz de píxeles, en la que cada pixel será considerado como error si se supera el umbral.
   \item TK-00043: Dibujado de los píxeles con defecto en una imagen nueva (máscara).
   \item TK-00044: Superposición de la máscara con la imagen original para crear la nueva imagen.
   \item TK-00045: Dibujado de la imagen en el panel de visualización.
  \end{itemize}
 \item S-01022: La aplicación debe ser capaz de usar varios tipos de métodos para determinar si una ventana es defectuosa o no.
  \begin{itemize}
   \item TK-00046: Implementación de "píxel central -> todo mal".
   \item TK-00047: Creación del ARFF para que se pueda usar en regresión (valor de la clase numérico).
   \item TK-00048: Implementación de "píxel central más tanto por ciento de vecinos".
   \item TK-00049: Implementación de "porcentaje de todos los píxeles de la ventana".
   \item TK-00050: Entrenamiento de un modelo de regresión lineal y usarlo para clasificar.
  \end{itemize}
 \item S-01023: La aplicación debe mostrar un slider para seleccionar el umbral de detección.
  \begin{itemize}
   \item TK-00051: Creación del slider, junto con su Listener.
  \end{itemize}
\end{itemize}

\subsubsection*{Burndown chart}
En el \burndownchart{} \ver{burndownChartSprint5} podemos ver que el desarrollo fue bastante cercano a la recta de "ideal".

%Burndown chart del Sprint 5.
\figura{1}{imgs/burndownChartSprint5.png}{Burndown Chart del quinto Sprint}{burndownChartSprint5}{}

Esto hizo que, pese a tener mucha carga de trabajo en este \sprint{}, terminásemos dentro del tiempo. Fue una buena planificación.

\subsubsection*{Retrospective meeting}
¿Qué ha ido bien?
\begin{itemize}
 \item El dibujado de defectos del año pasado funciona muy bien, por lo que hemos decidido mantenerlo.
 \item La regresión lineal funciona.
 \item Es muy sencillo generar el fichero de opciones. Decidimos meter alguna más.
 \item Dos de las nuevas formas de determinar si una ventana es defectuosa han resultado ser muy buenas, por lo que se mejora la precisión respecto al año pasado.
 \item El log con colores queda más intuitivo que el del año pasado.
 \item Se solucionó el problema de la escritura en los ARFF.
 \item Buena planificación del \sprint{}.
\end{itemize}

¿Qué dificultades ha habido?
\begin{itemize}
 \item No hemos encontrado ninguna forma de automatizar el valor del umbral de detección de defectos. Se deja, por lo tanto, con el slider sin más.
 \item La barra de progreso nos ha dado algunos problemas.
\end{itemize}



\subsection{Sprint 6}
\subsubsection*{Planning meeting}
En este \sprint{} lo que se pretende es:

\begin{itemize}
\item Cambiar la escritura del log por HTML.
\item Exportación del log.
\item Crear un menú de opciones avanzadas, aprovechando las posibilidades que nos da el fichero de opciones.
\item Arreglar un fallo con la primera y segunda derivadas.
\item Implementar dos nuevas formas de enfocar la detección de defectos
\end{itemize}

Las nuevas formas de detección de defectos son las que ya se explicaron en la parte teórica de la memoria:

\begin{itemize}
\item Detección normal más intersección con filtros de umbrales locales.
\item Lista de píxeles blancos en umbrales locales.
\end{itemize}

Además, también se habla de otras cosas, como que la documentación \textit{Javadoc} debería ir en inglés y que se deben añadir todas las mejoras que hemos hecho a la presente memoria.

\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este \sprint{} se inicia el 12/03/2013 y tiene como fecha límite el 26/03/2013. Tiene un total de puntos estimados de 18.

\subsubsection*{Sprint planning}
\begin{itemize}
 \item S-01024: La aplicación debe ser capaz de escribir texto formateado en HTML en el panel de log.
  \begin{itemize}
   \item TK-00052: Crear un CSS con una clase por cada tipo de cadena.
   \item TK-00053: Sustituir las escrituras con SImpleAttributeSet por HTML.
  \end{itemize}
 \item S-01025: La aplicación debe ser capaz de exportar el log en formato HTML.
  \begin{itemize}
   \item TK-00054: Creación del botón junto con su listener.
   \item TK-00055: Escritura del texto formateado en HTML en el fichero seleccionado.
  \end{itemize}
 \item S-01026: La aplicación debe tener un menú con varias opciones.
  \begin{itemize}
   \item TK-00056: Creación de la barra de menús, con sus diferentes apartados.
   \item TK-00057: Creación del diálogo de "opciones avanzadas".
  \end{itemize}
 \item S-01027: La aplicación debe usar REPTree para regresión lineal.
  \begin{itemize}
   \item TK-00058: Sustituir LinearReggression por REPTree.
  \end{itemize}
 \item S-01028: La aplicación debe ser capaz de calcular filtros de umbrales locales y comprobar si las regiones candidatas están dentro de la máscara.
  \begin{itemize}
   \item TK-00059: Calcular filtros de umbrales locales.
   \item TK-00060: Comprobar píxeles de regiones candidatas.
   \item TK-00061: Segmentar el defecto.
  \end{itemize}
 \item S-01029: La aplicación debe dirigir la búsqueda de defectos usando filtros de umbrales locales.
  \begin{itemize}
   \item TK-00062: Calcular filtros de umbrales locales.
   \item TK-00063: Sacar lista de píxeles marcados como blancos en los umbrales locales.
   \item TK-00064: Dividir la lista en tantas partes como hilos haya.
   \item TK-00065: Centrar una ventana en cada píxel de las regiones candidatas, calcular características y clasificar.
   \item TK-00066: Segmentar el defecto con el algoritmo actual.
  \end{itemize}
 \item B-01001: BUG: la primera y segunda derivadas deben estar bien calculadas.
  \begin{itemize}
   \item TK-00067: Verificar, comprobar y arreglar la primera y segunda derivadas.
  \end{itemize}
\end{itemize}

\subsubsection*{Burndown chart}
En el \burndownchart{} \ver{burndownChartSprint6} podemos ver que el desarrollo fue cercano a la recta de "ideal".

%Burndown chart del Sprint 6.
\figura{1}{imgs/burndownChartSprint6.png}{Burndown Chart del sexto Sprint}{burndownChartSprint6}{}

Esto hizo que terminásemos dentro de tiempo. Es más, podríamos incluso haber metido más carga de trabajo, ya que terminamos algo antes de tiempo. La planificación no fue mala.

\subsubsection*{Retrospective meeting}
¿Qué ha ido bien?
\begin{itemize}
 \item El log en HTML queda muy bien y es muy sencillo de hacer.
 \item La exportación del log ha quedado mucho más fina que la del año pasado.
 \item Ha sido sencillo adaptar las clases de ImageJ para poder usar los umbrales locales.
 \item El uso de los umbrales locales nos da más conocimientos sobre análisis de imágenes y nos abre una nueva forma de poder solucionar el problema.
 \item Se solucionó el problema de la barra de progreso.
 \item Se refinó el cálculo de la primera y segunda derivadas usando métodos de ImageJ.
 \item El menú ha sido muy fácil de hacer y nos permite muchas opciones.
 \item Buena planificación del \sprint{}.
\end{itemize}

¿Qué dificultades ha habido?
\begin{itemize}
 \item La segunda aproximación de la detección de defectos (lista de píxeles blancos) no devuelve tan buenos resultados como pensábamos.
\end{itemize}


\subsection{Sprint 7}
\subsubsection*{Planning meeting}
En este \sprint{} lo que se pretende es:

\begin{itemize}
\item Permitir al usuario elegir más opciones.
\item Mejorar el cálculo de los umbrales locales.
\item Calcular características geométricas sobre los defectos dibujados.
\item Mostrar una tabla resumen.
\item Intentar encontrar una buena solución para el problema de los autovalores.
\item Solucionar el problema de la lista de píxeles blancos.
\end{itemize}

Como vemos, se van a poner en práctica ideas ya comentadas en reuniones anteriores.

\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este \sprint{} se inicia el 26/03/2013 y tiene como fecha límite el 18/04/2013. Lo hemos planificado con una semana extra debido a que están las vacaciones de Semana Santa de por medio y nos puede dar problemas. Tiene un total de puntos estimados de 22.

\subsubsection*{Sprint planning}
\begin{itemize}
 \item S-01030: La aplicación debe dar la oportunidad al usuario de elegir el proceso de detección de defectos.
  \begin{itemize}
   \item TK-00068: Adición de las opciones a la interfaz.
   \item TK-00069: Lanzamiento de una opción u otra según la selección.
  \end{itemize}
 \item S-01031: La aplicación debe calcular los umbrales locales con un pequeño margen.
  \begin{itemize}
   \item TK-00070: Generación de la imagen a calcular, partiendo de la selección más el radio del algoritmo.
  \end{itemize}
 \item S-01032: La aplicación debe ser capaz de generar un conjunto de datos a partir de la ventana deslizante.
 \begin{itemize}
   \item TK-00071: Generación de un arff a partir de la ventana deslizante.
   \item TK-00072: Inclusión de la opción en la interfaz.
  \end{itemize}  
 \item S-01033: La aplicación debe poder remuestrear la lista de píxeles blancos, de tal manera que no considere todos.
 \begin{itemize}
   \item TK-00073: Sacar una lista de ROIs marcados como blancos en los umbrales locales.
   \item TK-00074: Crear una regla para decidir si el píxel que toca realmente se va a considerar o no.
  \end{itemize}
 \item S-01034: La aplicación debe ser capaz de calcular características geométricas sobre las regiones segmentadas.
 \begin{itemize}
  \item TK-00075: Cambiar la llamada a ParticleAnalyzer para que calcule características geométricas.
  \item TK-00076: Creación de un método para mostrar los resultados por cada ROI.
 \end{itemize}
 \item S-01035: Se debe poder mostrar una tabla resumen de los defectos.
  \begin{itemize}
   \item TK-00077: Generación de una JTable en la interfaz que contenga una fila por cada región.
  \end{itemize}
\end{itemize}

\subsubsection*{Burndown chart}
En el \burndownchart{} \ver{burndownChartSprint7} podemos ver que hubo una primera parte en la que la curve es totalmente plana. Coincide con las vacaciones.

%Burndown chart del Sprint 7.
\figura{1}{imgs/burndownChartSprint7.png}{Burndown Chart del séptimo Sprint}{burndownChartSprint7}{}

Pese a ello, terminamos a tiempo. Esto es debido a que tuvimos en cuenta esta eventualidad, dando lugar a una buena planificación.


\subsubsection*{Retrospective meeting}
¿Qué ha ido bien?
\begin{itemize}
 \item Se vuelve a ver que el fichero de opciones nos da muchas posibilidades para personalizar el funcionamiento de la aplicación.
 \item El cálculo de las características geométricas funciona perfectamente.
 \item Se ha encontrado una buena solución al problema de los autovalores con \textit{EJML}, aunque sigue siendo algo lento. Tendremos que decidir si lo usamos finalmente o no.
\end{itemize}

¿Qué dificultades ha habido?
\begin{itemize}
 \item No se ha solucionado del todo el problema del remuestreo de píxeles blancos. Lo que hemos hecho es considerar aleatoriamente píxeles de cada región, hasta un máximo del 10\% del área de la misma. Esto provoca que se consideren muy pocos píxeles, por lo que habrá que probar con un porcentaje mayor.
\end{itemize}


\subsection{Sprint 8}
\subsubsection*{Planning meeting}
En este \sprint{} lo que se pretende es:

\begin{itemize}
\item Dejar el código limpio y bien refactorizado, ya que se pretende que sea la ultima iteración.
\item Añadir las últimas funcionalidades: permitir seleccionar una fila de la tabla resumen e iluminar el defecto al que pertenece y viceversa, es decir, seleccionar un defecto en la imagen e iluminar la fila a la que pertenece.
\item Mejorar el margen de la selección al calcular umbrales locales.
\item Permitir al usuario seleccionar más opciones.
\item Permitir el cálculo de sólo las mejores características.
\item Incluir un módulo de ayuda en línea, que el año pasado no existía.
\item Solucionar algún BUG.
\end{itemize}

Además, se dan algunas ideas para líneas futuras, ya que a nosotros ya no nos da tiempo a meter más funcionalidad. Por ejemplo, se propone dar la opción al usuario de elegir él mismo qué características quiere calcular, automatizar la selección de las mejores características... También se propone comprobar qué tal funcionan las operaciones morfológicas de ImageJ, para ver si se puede incluir algo en nuestro proyecto o dejarlo como línea futura.

Se habla también de aspectos de la memoria, ya que tenemos que añadir unas breves descripciones de los algoritmos de clasificación utilizados y se determina que debemos incluir una extensa comparativa con el proyecto del año pasado en un anexo propio.

Por lo tanto, en este último \sprint{} pretendemos cerrar (o prácticamente dejarlo cerrado) toda la parte del código del proyecto, para dedicarnos a partir de aquí a finalizar la memoria y realizar una extensa comparativa con el año pasado (métricas, rendimiento...).


\subsubsection*{Fechas de desarrollo y tiempo estimado}
Este \sprint{} se inicia el 18/04/2013 y tiene como fecha límite el 01/05/2013. Tiene un total de 22 puntos estimados.


\subsubsection*{Sprint planning}
\begin{itemize}
 \item S-01036: La aplicación debe permitir al usuario qué tipo de clasificación se va a usar: clases nominales o regresión.
  \begin{itemize}
   \item TK-00078: Añadir la opción al fichero de propiedades, junto con su set y su get.
   \item TK-00079: Añadir la opción al diálogo de opciones avanzadas.
  \end{itemize}
 \item S-01037: La aplicación debe añadir un borde a la selección en aquellas zonas que no coincidan con los bordes de la imagen.
  \begin{itemize}
   \item TK-00080: Modificar margen umbrales locales.
  \end{itemize}
 \item S-01038: La aplicación debe permitir al usuario qué tipo de ventana defectuosa quiere usar.
  \begin{itemize}
   \item TK-00081: Añadir la opción al fichero de opciones, junto con su set y su get.
   \item TK-00082: Añadir la opción al diálogo de opciones avanzadas.
   \item TK-00083: Añadir un Slider para seleccionar el porcentaje.
  \end{itemize}
 \item S-01039: Se debe añadir un módulo de ayuda en línea (JavaHelp), accesible desde el menú y con teclas rápidas (F1).
  \begin{itemize}
   \item TK-00084: Implementación del módulo de ayuda en línea.
   \item TK-00085: Crear un buscador.
   \item TK-00086: Implementar el acceso a la ayuda desde el menú y desde teclas rápidas (F1).
  \end{itemize}
 \item S-01040: La aplicación debe poder permitir seleccionar una fila de la tabla de resultados e iluminar el defecto correspondiente.
  \begin{itemize}
   \item TK-00087: Al seleccionar una fila, dibujar sólo el ROI al que pertenece.
   \item TK-00088: Al seleccionar un defecto en la imagen, mostrar a qué fila de la tabla pertenece.
  \end{itemize}
 \item S-01041: La aplicación debe dar la opción de elegir si se calculan todas las características o sólo mejores.
  \begin{itemize}
   \item TK-00089: Añadir la opción al fichero de propiedades, junto con su get y su set.
   \item TK-00090: Añadir la opción al diálogo de opciones avanzadas.
   \item TK-00091: En función de la opción, seleccionar todas las características o sólo las mejores.
  \end{itemize}
 \item S-01042: La aplicación debe tratar las excepciones de forma correcta, mostrando avisos.
  \begin{itemize}
   \item TK-00092: Capturar las excepciones de los hilos y almacenarlas..
   \item TK-00093: Parar los hilos que aún estén en ejecución.
   \item TK-00094: En el hilo de la interfaz comprobar si hay excepciones lanzadas. En caso positivo mostrar un mensaje con la excepción pertinente.
  \end{itemize}
 \item B-01002: BUG: la aplicación debe impedir la reselección mientras se analiza.
  \begin{itemize}
   \item TK-00095: Deshabilitar la selección de regiones mientras se analiza.
  \end{itemize}
\end{itemize}


\subsubsection*{Burndown chart}
Aún no hay.


\subsubsection*{Retrospective meeting}
Aún no hay.
